load_kdump_config

MAIN_FOLDER="${MOUNT_FOLDER}"

if [ ! -d "${MAIN_FOLDER}" ]; then
	logger "kdump: invalid folder (${MAIN_FOLDER}) - aborting..."
	exit 1
fi

# Use UTC timezone to match kdump collection
CURRENT_TSTAMP=$(date -u +"%Y%m%d%H%M")
KDUMP_TMP_FOLDER="${MAIN_FOLDER}/.tmp"

#  By default, pstore is mounted in this location; if it isn't, we move on.
#  Notice we currently only support the logs generated by the ramoops backend.
LOGS_FOUND=0
PSTORE_FOLDER="${KDUMP_TMP_FOLDER}/pstore"

while IFS= read -r log
do
	if [[ "${log}" == *"dmesg-ramoops"* ]]; then
		SAVED_FILE="${PSTORE_FOLDER}/dmesg-pstore.${CURRENT_TSTAMP}-${LOGS_FOUND}"
		mkdir -p "${PSTORE_FOLDER}"

		cat "${log}" > "${SAVED_FILE}"
		sync "${SAVED_FILE}"
		rm -f "${log}"
		LOGS_FOUND=$((LOGS_FOUND + 1))
	fi
done <<< "$(find /sys/fs/pstore/ -type f 2>/dev/null)"

if [ "${LOGS_FOUND}" -gt 0 ]; then
	#  Logs should live on <...>/.tmp folder, due to the zip compression.
	mv "${PSTORE_FOLDER}"/* "${KDUMP_TMP_FOLDER}/" 2>/dev/null
	rm -rf "${PSTORE_FOLDER}"
fi

#  Now, proceed the same way if there are kdump data.
CRASHES_FOUND=0
KDUMP_CRASH_FOLDER="${MAIN_FOLDER}/crash"

while IFS= read -r crash
do
	#  When collecting the vmcore/dmesg during kdump, folder is
	#  saved with its name == the timestamp of the collection.
	CRASH_TSTAMP=$(basename "${crash}")
	if [[ ! "${CRASH_TSTAMP}" =~ ^[0-9]{12}$ ]]; then
		continue
	fi

	KD_FOLDER="${KDUMP_TMP_FOLDER}/kdump"
	mkdir -p "${KD_FOLDER}"

	if [ -s "${crash}/dmesg.txt" ]; then
		SAVED_FILE="${KD_FOLDER}/dmesg-kdump.${CRASH_TSTAMP}"
		mv "${crash}/dmesg.txt" "${SAVED_FILE}"
		sync "${SAVED_FILE}"
		CRASHES_FOUND=$((CRASHES_FOUND + 1))
	fi

	#  We won't pack vmcores in the zip blob, but let's save
	#  it in case it was collected as well.
	if [ -s "${crash}/vmcore.compressed" ]; then
		SAVED_FILE="${KDUMP_CRASH_FOLDER}/vmcore.${CRASH_TSTAMP}"
		mv "${crash}/vmcore.compressed" "${SAVED_FILE}"
		sync "${SAVED_FILE}"
	fi

	rm -rf "${crash}"
done <<< "$(find "${KDUMP_CRASH_FOLDER}"/ -mindepth 1 -type d 2>/dev/null)"

if [ "${CRASHES_FOUND}" -gt 0 ]; then
	#  Logs should live on .tmp folder, due to the zip compression.
	mv "${KD_FOLDER}"/* "${KDUMP_TMP_FOLDER}/" 2>/dev/null
	rm -rf "${KD_FOLDER}"
	LOGS_FOUND=$((LOGS_FOUND + CRASHES_FOUND))
fi


# If we have pstore and/or kdump logs, let's process them...
LOGS_FOLDER="${MAIN_FOLDER}/logs"

if [ "${LOGS_FOUND}" -ne 0 ]; then
	mkdir -p "${LOGS_FOLDER}"

	#  First  we collect some more info, like DMI data, os-release, etc;
	DMI_FNAME="${KDUMP_TMP_FOLDER}/dmidecode.${CURRENT_TSTAMP}"
	dmidecode > "${DMI_FNAME}"

	BUILD_FNAME="${KDUMP_TMP_FOLDER}/build.${CURRENT_TSTAMP}"
	cp "/etc/os-release" "${BUILD_FNAME}"

	VERSION_FNAME="${KDUMP_TMP_FOLDER}/version.${CURRENT_TSTAMP}"
	uname -r > "${VERSION_FNAME}"

	sync "${DMI_FNAME}" "${BUILD_FNAME}" "${VERSION_FNAME}"

	#  Create the dump compressed pack.
	LOG_FNAME="kdump-${CURRENT_TSTAMP}.zip"
	LOG_FNAME="${LOGS_FOLDER}/${LOG_FNAME}"
	zip -9 -jq "${LOG_FNAME}" "${KDUMP_TMP_FOLDER}"/* 1>/dev/null

	sync "${LOG_FNAME}" 2>/dev/null
	if [ ! -s "${LOG_FNAME}" ]; then
		logger "kdump: couldn't create the compressed log archive"
		logger "kdump: check folder \"${KDUMP_TMP_FOLDER}\" for logs"
		exit 0
	else
		logger "kdump: logs saved in \"${LOGS_FOLDER}\""
	fi
fi

rm -rf "${KDUMP_TMP_FOLDER}"
